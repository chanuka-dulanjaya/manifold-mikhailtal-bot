"""
Base Strategy Class
All trading strategies inherit from this
"""
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)


@dataclass
class StrategySignal:
    """Signal generated by a trading strategy"""
    probability: float  # Estimated probability (0-1)
    confidence: float  # Confidence in the estimate (0-1)
    direction: str  # 'YES' or 'NO'
    reasoning: str  # Explanation of the signal
    strength: float  # Signal strength (0-1)
    
    @property
    def weighted_probability(self) -> float:
        """Probability weighted by confidence"""
        return self.probability * self.confidence


class BaseStrategy(ABC):
    """Abstract base class for trading strategies"""
    
    def __init__(self, name: str, config: Dict[str, Any] = None, **kwargs):
        self.name = name
        self.config = config or kwargs  # Accept either config dict or kwargs
        self.performance_history = []
        self.enabled = True
    
    @abstractmethod
    def analyze(self, market: Dict[str, Any], **kwargs) -> Optional[StrategySignal]:
        """
        Analyze a market and generate a trading signal
        
        Args:
            market: Market data dictionary
            **kwargs: Additional context (bets, comments, etc.)
        
        Returns:
            StrategySignal or None if no signal
        """
        pass
    
    def should_trade(self, market: Dict[str, Any], signal: StrategySignal) -> bool:
        """
        Determine if we should trade based on the signal
        
        Args:
            market: Market data
            signal: Generated signal
        
        Returns:
            True if should trade, False otherwise
        """
        if not signal:
            return False
        
        # Basic checks
        if signal.confidence < 0.3:  # Minimum confidence threshold
            return False
        
        if signal.strength < 0.2:  # Minimum signal strength
            return False
        
        # Check for sufficient edge
        current_prob = market.get('probability', 0.5)
        edge = abs(signal.probability - current_prob)
        
        min_edge = self.config.get('min_edge', 0.05)
        if edge < min_edge:
            return False
        
        return True
    
    def calculate_edge(self, market_prob: float, estimated_prob: float) -> float:
        """Calculate trading edge"""
        return abs(estimated_prob - market_prob)
    
    def record_performance(self, trade: Dict[str, Any], result: Dict[str, Any]):
        """Record strategy performance for a trade"""
        self.performance_history.append({
            'trade': trade,
            'result': result,
            'timestamp': result.get('timestamp')
        })
    
    def get_performance_metrics(self) -> Dict[str, float]:
        """Calculate performance metrics"""
        if not self.performance_history:
            return {
                'total_trades': 0,
                'win_rate': 0.0,
                'avg_return': 0.0,
                'total_return': 0.0
            }
        
        total_trades = len(self.performance_history)
        wins = sum(1 for p in self.performance_history if p['result'].get('profit', 0) > 0)
        total_return = sum(p['result'].get('profit', 0) for p in self.performance_history)
        
        return {
            'total_trades': total_trades,
            'win_rate': wins / total_trades if total_trades > 0 else 0,
            'avg_return': total_return / total_trades if total_trades > 0 else 0,
            'total_return': total_return
        }
    
    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}(name='{self.name}')>"